# 코루틴을 써야하는 이유

코틀린에 등장해 비동기 솔루션을 헤집어 다니고 있는 괴물 같은 녀석!

**코루틴(Kotlin-Coroutine → 일명 Koroutine)**에 대해 알아보자.

### 코루틴은 동시성 프로그래밍이다.

이게 무슨 말이까? 동시성 프로그래밍?

일단 3가지 방식이 존재한다.

Sequential(순차적), Parallel(병렬성), Concurrent(동시성)이다.

Sequential 먼저 알아볼까?

Sequential은 A랑 B라는 일이 있으면, A를 처리하고 난 후에 B를 처리하는 식으로 **순차적**으로 작업을 처리하는 것을 말한다.

반면에 Parallel은

A랑 B라는 일이 있으면 동시에 두 가지 일을 자원을 조금 더 들여서 처리하는 식으로 **병렬적**으로 작업을 처리하는 것을 말한다.

그럼 Concurrent는?,

Concurrent는 A랑 B라는 일이 있으면 A를 조금 처리 했다가, B를 조금 처리 했다가 하면서 엄청나게 빠르게 A와 B를 왔다갔다하면서 마치 동시에 A와 B를 처리하는 것처럼 보이게 처리하는 식으로 **동시적**으로 작업을 처리하는 것을 말한다.

그래서! 동시성 프로그래밍을 하기 위한 솔루션이 바로! **코루틴**이다.

### 코루틴은 경량화된 스레드이다.

코루틴을 공부, 혹은 써본 적이 있는 사람들은 한 번씩은 들어본 말일 것이다.

경량화된 스레드….. 말이 어렵다.(이이잉…😠)

왜 코루틴을 스레드에 비교해서 말하는 걸까.

이 부분은 동시성 프로그래밍과도 엮어서 설명이 가능하다.

스레드는 여러 작업을 동시에 처리해야 할 때 스레드를 통해 동시성 프로그래밍이 가능하다.

스레드는 여러 작업을 동시에 처리해야 할 때 어떤 작업을 먼저 할지, 어떻게 하면 어떤 스레드에서 더 많이 작업해야될지를 결정하는 선점 스케줄링을 해야 한다.

스레드는 동시성 프로그래밍을 하기 위해 **context switching**과 **블로킹(Blocking)**을 이용해서 작업들을 동시적으로 처리한다.

> ex : Thread A와 Thread B가 존재한다. Thread A에서 Thread B의 작업에서 반환되는 결과값이 필요한 경우에 Thread A는 작업을 멈추고(블로킹 되고) Thread A에서 B로 context switching되어 Thread B의 작업이 끝나기를 기다려야한다. Thread B의 작업이 끝난 다음 Thread B의 작업 결과값을 넘겨주기 위해 Thread A로 또 context switching된다.

코루틴을 볼까?

코루틴은 여러 작업을 동시에 처리해야 할 때 coroutine object를 통해 동시성 프로그래밍이 가능하다.

코루틴은 여러 작업을 동시에 처리해야 할 때 여러 작업 각각에 object를 할당한다. coroutine object는 객체이기 때문에 jvm heap에 적재된다,

코루틴은 동시성 프로그래밍을 하기 위해 **suspend**를 이용해서 작업을 동시적으로 처리한다.

> ex : Thread A가 존재한다.  Thread A안에 있는 task1이 task2에서 반환되는 결과값이 필요한 경우에는 task1을 일시중단하고(suspend하고) task2로 **context switching 없이** 넘어가서 task2를 하나의 스레드에서 작업할 수 있다. 또한 하나의 스레드에서 여러 task들을 작업할 수 있다.

이렇게 코루틴은 context switching을 할 필요가 없어 context switching 비용을 낭비하지 않아도 되고 하나의 스레드에서 여러 코루틴들을 이용하여 동시성 프로그래밍이 가능하다.

이러한 측면의 폭발적인(?) 퍼포먼스 때문에, 코루틴이 **경량화된 스레드**라고 불리우는 이유이다.

### 그 외 장점들(like e.t.c)

**구조화된 동시성 - 메모리 누수 감**

코루틴은 구조화된 동시성을 사용하여 코루틴을 안전하게 사용할 수 있도록 도와준다.

코루틴의 수명을 결정짓는 **코루틴 스코프(CoroutineScope)**가 그 구조화를 도와준다.

코루틴은 코루틴 스코프 안에서만 시작될 수 있다. 외부 스코프는 모든 하위 루틴이 끝나기 전까지 완료될 수 없고, 이렇듯 구조화된 동시성이라는 특성은 코드의 오류가 제대로 뜨게하고, 코드가 손실되지 않게 보존해준다.

**Jetpack에서의 지원**

코루틴을 사용하거나 지원하는 Jetpack 라이브러리들이 많아지고 있다는 걸 새삼 느낀다.

예시로 DataStore를 제일 최근에 본 것 같다. 이건 뭐… 장점일래야 장점일 수 밖에 없지..👍